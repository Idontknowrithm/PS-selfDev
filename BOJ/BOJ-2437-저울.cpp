// 코드만 보면 상당히 쉬워보이는 것 같지만 문제 자체의 매커니즘에 대해서 깊게
// 생각해봐야 이 문제를 풀 수 있었다. 일단 N의 크기가 1000이니까 하나씩 껐다 
// 켜보는 O(2^n)로는 어림도 없을테니, 완탐은 안될 것 같고.. 완탐으로 풀 수 
// 있는 문제니까 이를 최적화 해서 DP로 풀면 O(n^2) 정도로 되지 않을까? 라는
// 안일한 생각으로 재귀 DP함수를 설계해봤다. 시도 방향은 DP(sum, idx): idx
// 전까지의 내가 고른 추의 무게 합이 sum인 경우 - 인데 이때 sum의 값은 현재
// 추로 만든 무게이므로 bool 형의 cache 배열을 따로 만들어서 sum 값이 되면
// true, 즉 이 무게를 추로 만들 수 있다는 것을 메모이제이션 하려고 했는데, 
// 생각해보면 답으로 가능한 정수의 범위가 1부터 50만 까지고, idx가 N, 즉 
// 1000까지 들어올 수 있으므로 50만 * 1000 짜리 2차원 배열을 만들 수 없으니 
// 일단 실패다. 다음은 BFS로도 시도해봤는데 시도 방향은 일단 큐에 pair로 
// {0, 0}을 넣는다. 이는 방금의 sum과 idx를 의미하고 while(!queue.empty())
// 반복문 안에서 queue.push({sum + 추[idx], idx + 1})과 queue.push({sum, idx + 1}) 
// 두 개를 추가함으로써 이번 추 인덱스를 추가하고 다음 인덱스를 찾아보는 것과 
// 이번 추를 무시하고 다음 인덱스를 찾아보는 것으로 생각했는데, 그대로 가게되면 
// O(2^n)이 되니까 중간에 중복되는 것을 막는 조건문을 넣어야하는데, 이 조건문이 
// 자꾸 예외 사항을 만들어서 또 틀렸다. 그래서 결국 답안 블로그를 찾아봤는데, 
// 그리디를 사용하더라.. 해답은, 먼저 오름차순으로 정렬을 한 후, 지금의 추 idx가 
// 그 전 idx들의 무게 합 + 1보다 작거나 같으면 idx의 추까지의 모든 추의 무게의 
// 합을 나타낼 수 있고, 그 이상이면 idx 전의 추의 무게의 합 까지만 모든 정수를
// 나타낼 수 있다는 점을 사용한다. 예를 들어 1, 2, 3, 7이 있다 해보자. 7을 
// 생각하면, 그 전의 합은 6이고, 6+1=7이므로 여기선 1부터 13까지 모든 수를 
// 나타낼 수 있지만, 1, 2, 3, 8을 보면, 1, 2, 3의 합 6에 1을 더한 7을 
// 표현하지 못한다는 것을 알 수 있다. 따라서 이 예시에서는 7이 답이 될 수 있다

#include<iostream>
#include<algorithm>

int N, sum, weights[1005];

int main() {

    scanf("%d", &N);
    for(int i = 0; i < N; ++i)
        scanf("%d", &weights[i]);
    std::sort(weights, weights + N);

    for(int i = 0; i < N; ++i){
        if(weights[i] > sum + 1){
            break;
        }
        sum += weights[i];
    }
    printf("%d", sum + 1);
    
    return 0;
}
