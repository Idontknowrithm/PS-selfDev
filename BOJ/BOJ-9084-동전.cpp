// DP 문제에 대해서 너무 같은 방법으로 풀이하려고 한다
// DP 문제만 보면 무조건 재귀 DP를 이용해서 해결하려고 하다보니까
// 이 문제를 어떻게 재귀로 풀지 하는 생각에 다양한 접근을 하지 못하는 것 같다
// 상황에 따라서 반복문 DP함수를 구현할 수 있어야할 것 같다
// 이번은 동전의 종류(N 개)가 주어질 때 주어진 금액(M)을 만드는 '모든' 경우의 수를 세어야한다
// --> DP 캐시에 어떠한 수들을 더해가는 알고리즘을 구현해야한다
// 이때 1+2+1+2와 2+1+2+1 경우를 같은 경우로 쳐야 하므로 이와 같은 중복은
// 일어나지 않도록 주의하며 알고리즘을 설계하자
// 이때 사용된 critical point는 동전 종류의 순서대로 탐색하면서
// 특정 동전을 마지막으로 사용하면서 값의 합이 tmp가 되는 경우의 수를 세어보는 것이다
// 1, 2, 3 동전으로 3원을 만드는 경우의 수를 생각:
// 1로 1 만들기 -> 0+1 = 1
// 1로 2 만들기 -> 1+1 = 1
// 1로 3 만들기 -> 1+1+1 = 1
 
// 2로 1 만들기 -> x
// 2로 2 만들기 -> 0+2 = 1 -> 1+1, 0+2 = 2
// 2로 3 만들기 -> 1+2 = 1 -> 1+1+1, 1+2 = 2

// 3으로 3 만들기 -> 0+3 = 1 -> 1+1+1, 1+2, 0+3 = 3

#include<iostream>
#include<cstring>

int T, N, M, coins[25], cache[10005];

int DP(){
    for(int i = 0; i < N; ++i){
        for(int u = 1; u <= M; ++u){
            if(u - coins[i] >= 0)
                cache[u] += cache[u - coins[i]];
        }
    }
    return cache[M];
}

int main() {
    for(scanf("%d", &T); T > 0; --T){
        scanf("%d", &N);
        for(int i = 0; i < N; ++i)
            scanf("%d", &coins[i]);
        scanf("%d", &M);
        memset(cache, 0, sizeof(cache));
        cache[0] = 1;
        printf("%d\n", DP());
    }
    return 0;
}
